"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const HTTPS = __importStar(require("https"));
const HTTP = __importStar(require("http"));
const URL = __importStar(require("url"));
const fs_1 = require("fs");
var timeout_num = 30 * 1000;
var taskGenId = 0;
function makeTaskId() {
    ++taskGenId;
    return taskGenId;
}
var task_cache = {};
let cert_cache = {};
function loadCert(name, cert_path, key_path, passphrase) {
    try {
        cert_cache[name] = {
            cert: fs_1.readFileSync(cert_path),
            key: fs_1.readFileSync(key_path),
            pass: passphrase
        };
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.loadCert = loadCert;
/**
 * 异步流程执行网络请求
 * @param type
 * @param url
 * @param data
 * @param retry
 * @param headers
 * @param dtype
 * @param rtype
 */
function http_quest(type, url, data = {}, retry = 0, headers = {}, _option) {
    // 这里url增加一个 http https 头检查
    let checkHead = url.slice(0, 7);
    if (checkHead != 'http://' && checkHead != 'https:/') {
        // 自动增加一个头上去
        url = 'http://' + url;
    }
    type = type.toLowerCase();
    return new Promise(function (resolve, reject) {
        let option = {};
        if (typeof _option == 'string') {
            option = { dtype: _option };
        }
        else {
            option = Object.assign(option, _option || {});
        }
        var taskId = makeTaskId();
        task_cache[taskId] = {
            taskId: taskId,
            url: url,
            retry: retry,
            data: data,
            type: type,
            headers: headers,
            option: option,
            resolve: resolve,
            reject: reject
        };
        make_quest(taskId);
    });
}
exports.http_quest = http_quest;
function onResponse(taskid, res) {
    let task = task_cache[taskid];
    if (task) {
        task.res = res;
        if (res) {
            let size = Math.min(parseInt(res.headers["content-length"] || '1024'), 128 * 1024);
            task.respon_data = Buffer.alloc(size);
            task.respon_len = 0;
            res.on("data", onData.bind(null, taskid));
            res.on("end", onEnd.bind(null, taskid));
            res.on("error", onEnd.bind(null, taskid));
        }
        else if (!task.respon_data) {
            // 表示开始接收数据了，就不需要超时标志了
            if (task.retry > 0) {
                --task.retry;
            }
            else {
                onEnd(taskid);
            }
        }
    }
}
function onData(taskid, data) {
    let info = task_cache[taskid];
    if (!info || info.respon_len == undefined || info.respon_data == undefined)
        return;
    if (info.respon_len + data.length > info.respon_data.length) {
        // 数据不够放了，一般不存在,
        let nbuff = Buffer.alloc(info.respon_len + data.length + 2 * 1024); // 额外多2K的数据容量
        info.respon_data.copy(nbuff, 0, 0, info.respon_len);
        info.respon_data = nbuff;
    }
    info.respon_len += data.copy(info.respon_data, info.respon_len, 0, data.length);
}
function onEnd(taskid) {
    let info = task_cache[taskid];
    if (!info)
        return;
    let out = null;
    if (info.respon_data && info.respon_len) {
        out = info.respon_data.slice(0, info.respon_len);
    }
    switch (info.option.respon_type) {
        case 'json':
            try {
                out && (out = JSON.parse(out.toString()));
            }
            catch (e) {
                out && (out = out.toString());
            }
            break;
        case 'buffer':
            break;
        case 'text':
        case undefined:
            out && (out = out.toString());
            break;
        default:
            break;
    }
    if (out) {
        if (info.option.respon_head) {
            info.resolve([out, info.res ? info.res.headers : {}]);
        }
        else {
            info.resolve(out);
        }
    }
    else {
        if (info.option.respon_head) {
            info.reject(['404 ' + info.url, info.res ? info.res.headers : {}]);
        }
        else {
            info.reject('404 ' + info.url);
        }
    }
    delete task_cache[taskid];
}
function make_quest(taskId) {
    let task = task_cache[taskId];
    if (task.type == 'get') {
        http_get(task);
    }
    else if (task.type == 'post') {
        if (task.option.request_type == 'formdata') {
            let Needle = require('needle');
            Needle.post(task.url, task.data, { multipart: true }, function (err, res) {
                if (err) {
                    onEnd(taskId);
                    return;
                }
                let size = Math.min(parseInt(res.headers["content-length"] || '1024'), 128 * 1024);
                task.respon_data = Buffer.alloc(size);
                task.respon_len = 0;
                onData(taskId, res.raw);
                onEnd(taskId);
            });
        }
        else {
            http_post(task);
        }
    }
    else {
        process.nextTick(function () { onResponse(taskId); });
    }
}
function stringify(method, data) {
    if (typeof data == 'object') {
        let urldata = [];
        for (let key in data) {
            let value = data[key];
            if (typeof value == 'object') {
                value = JSON.stringify(value);
            }
            urldata.push(`${key}=${encodeURIComponent(value)}`);
        }
        return urldata.join('&');
    }
    if (data == undefined)
        data = '';
    return encodeURIComponent(data);
}
function http_get(task) {
    let url = task.url;
    let headers = task.headers;
    try {
        let urldata = stringify('get', task.data);
        if (urldata.length > 0) {
            if (url.indexOf('?') >= 0) {
                url = url + '&' + urldata;
            }
            else {
                url = url + '?' + urldata;
            }
        }
        let opt = URL.parse(url);
        if (headers) {
            if (!opt['headers'])
                opt['headers'] = {};
            for (let key in headers) {
                opt['headers'][key] = headers[key];
            }
        }
        let cert_info = cert_cache[task.option.ca_name || ''];
        if (cert_info) {
            opt.cert = cert_info.cert;
            opt.key = cert_info.key;
            opt.passphrase = cert_info.pass;
        }
        let r = (url.indexOf('https://') == 0) ? HTTPS.get(opt, function (res) { onResponse(task.taskId, res); }) : HTTP.get(opt, function (res) { onResponse(task.taskId, res); });
        r.on("error", function (e) { onResponse(task.taskId); });
        r.setTimeout(timeout_num, function () { onResponse(task.taskId); });
    }
    catch (e) {
        process.nextTick(function () { onResponse(task.taskId); });
    }
}
function http_post(task) {
    let url = task.url;
    let data = task.data;
    let headers = task.headers;
    let type = task.option.request_type || 'text';
    try {
        let contents = "";
        let Query = URL.parse(url);
        Query['method'] = 'POST';
        switch (type) {
            case 'plain': {
                contents = data;
                Query['headers'] = {
                    'Content-Type': 'text/plain',
                    'Content-Length': Buffer.byteLength(contents)
                };
                break;
            }
            case 'json': {
                if (typeof data == 'string') {
                    contents = data;
                }
                else {
                    contents = JSON.stringify(data);
                }
                Query['headers'] = {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(contents)
                };
                break;
            }
            case 'xml': {
                contents = data;
                Query['headers'] = {
                    'Content-Type': 'text/xml',
                };
                break;
            }
            default: {
                contents = stringify('post', data);
                Query['headers'] = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': contents.length
                };
                break;
            }
        }
        if (headers) {
            for (let key in headers) {
                Query['headers'][key] = headers[key];
            }
        }
        let cert_info = cert_cache[task.option.ca_name || ''];
        if (cert_info) {
            Query.cert = cert_info.cert;
            Query.key = cert_info.key;
            Query.passphrase = cert_info.pass;
        }
        let r = (url.indexOf('https://') == 0) ? HTTPS.request(Query, function (res) { onResponse(task.taskId, res); }) : HTTP.request(Query, function (res) { onResponse(task.taskId, res); });
        r.on("error", function () { onResponse(task.taskId); });
        r.write(contents, 'utf8');
        r.end();
        r.setTimeout(timeout_num, function () { onResponse(task.taskId); });
    }
    catch (e) {
        process.nextTick(function () { onResponse(task.taskId); });
    }
}
//# sourceMappingURL=HttpQuest.js.map