import { EventEmitter } from 'events';
import { ReHash, ReSubHash } from './ReHash';
import { ReHashList } from "./ReHashList";
import { ReList } from './ReList';
import { IFIndex, error } from './TeMongodb';
import MONGO from "mongodb"

export class TeMongoDBUnit extends EventEmitter {
    private db: MONGO.Db;
    private index_check_pool: IFIndex[] = [];
    private collections: string[] = [];
    private _collect_pool: any = {};
    private ready = false;
    check_ready() {
        if (this.ready) {
            setTimeout(this.emit.bind(this, 'ready'), 10);
        }
    }
    constructor(db: MONGO.Db, collections: string[] = [], col_indexs: IFIndex[]) {
        super();
        this.db = db;
        this.index_check_pool = col_indexs || [];
        this.collections = collections;
        this.db.collections(this._check_collections.bind(this));
        this.db.on('error', function (...s: any[]) {
            error('TeMongoDBUnit', JSON.stringify(s, null, 4));
        });
    }
    private _judge_count = 0;
    private _judge_index_finish() {
        if (this._judge_count > 0) {
            return;
        }
        // 都检查完了那么要创建不存在的index了
        // 检查一下要求的是否都在了
        for (var i = 0; i < this.collections.length; i++) {
            var rc = this.collections[i];
            if (rc && !this._collect_pool.hasOwnProperty(rc)) {
                this._ct_wait_list.push(rc);
                this.db.createCollection(rc, this._col_create_ret.bind(this, rc));
            }
        }
        this._create_index();
    }
    private _ct_wait_list: string[] = [];
    private _col_create_ret(rc: any, error: any, succ: any) {
        let idx = this._ct_wait_list.indexOf(rc);
        if (idx >= 0) {
            this._ct_wait_list.splice(idx, 1);
        }
        this._create_index();
    }
    private _create_index() {
        if (this._ct_wait_list.length != 0)
            return;
        // 表单创建好了，建立索引
        for (let i = 0; i < this.index_check_pool.length; i++) {
            let r = this.index_check_pool[i];
            if (this.collections.indexOf(r.col) >= 0) {
                this._check_index_keys(r);
                let wait_key = r.col + '_' + r.index;
                this._idx_wait_list.push(wait_key);
                this.db.createIndex(r.col, r.keys, r.option || {}, this._col_idx_create_ret.bind(this, wait_key));
            }
        }
        this._init_finish();
    }
    private _idx_wait_list: string[] = [];
    private _col_idx_create_ret(ct_str: any, err: any, result: any) {
        let idx = this._idx_wait_list.indexOf(ct_str);
        if (idx >= 0) {
            this._idx_wait_list.splice(idx, 1);
        }
        this._init_finish();
    }
    private _check_index_keys(r: any) {
        if (!r.keys) {
            r.keys = {};
            let arr_keys = r.index.split('_');
            for (let j = 0; j < arr_keys.length; j = j + 2) {
                if (j + 1 >= arr_keys.length) {
                    r.keys[arr_keys[j]] = 1;
                }
                else {
                    let nb = parseInt(arr_keys[j + 1]);
                    if (nb == arr_keys[j + 1]) {
                        r.keys[arr_keys[j]] = nb;
                    }
                    else {
                        r.keys[arr_keys[j]] = arr_keys[j + 1];
                    }
                }
            }
        }
    }
    private _judge_index(col: string, name: string, objs: any) {
        let keys = Object.keys(objs);
        for (let i = 0; i < this.index_check_pool.length; i++) {
            let r = this.index_check_pool[i];
            if (r.col != col)
                continue;
            this._check_index_keys(r);
            let same = true;
            for (let j = 0; j < keys.length; j++) {
                if (!r.keys.hasOwnProperty(keys[j])) {
                    same = false;
                    break;
                }
            }
            if (same) {
                this.index_check_pool.splice(i, 1);
                i--;
            }
        }
    }
    /**
     * 检查数据集是否存在
     */
    private _check_collections(a: any, b: MONGO.Collection[]) {
        if (a) {
            this.emit('error', a);
        }
        else {
            for (var i = 0; i < b.length; i++) {
                var bc = b[i];
                this._collect_pool[bc.collectionName] = true;
                this._judge_count++;
                bc.indexes(((col: any, error: any, indexs: {
                    name: string;
                    ns: string;
                    v: number;
                    key: Object;
                }[]) => {
                    for (let i = 0; i < indexs.length; i++) {
                        let name = indexs[i].name;
                        /**默认 索引不需要判断 */
                        if (name == '_id_')
                            continue;
                        this._judge_index(col, indexs[i].name, indexs[i].key);
                    }
                    this._judge_count--;
                    this._judge_index_finish();
                }).bind(this, bc.collectionName));
            }
            this._judge_index_finish();
        }
    }
    private _init_finish() {
        if (this._ct_wait_list.length != 0 || this._idx_wait_list.length != 0)
            return;
        // 表单和索引都建立好了，那么就完成初始化了
        this.ready = true;
        this.emit('ready');
    }
    public get_unit<T>(col_name: string, fObj: Object = {}, jugetfunc?: ((a: T, b: T) => number) | undefined, ...args: any[]) {
        return new ReHash<T>(this.db.collection(col_name), fObj, jugetfunc, args);
    }
    public get_sub_unit<T>(col_name: string, fObj: Object = {}, filter: string, jugetfunc?: ((a: T, b: T) => number) | undefined, ...args: any[]) {
        return new ReSubHash<T>(this.db.collection(col_name), fObj, filter, jugetfunc, args);
    }
    public get_list<T>(col_name: string, fObj: Object = {}, ...args: any[]) {
        return new ReList<T>(this.db.collection(col_name), fObj, args);
    }

    public get_unit_list<T>(col_name: string, fObj: Object = {}) {
        return new ReHashList<T>(this.db.collection(col_name), fObj);
    }
    /**
     * 直接插入数据，如果_id重复就异常
     * @param col_name
     * @param fObj
     * @param insert_value
     */
    public insert(col_name: string, insert_value: any) {
        return this.get_collection(col_name).insertOne(insert_value);
    }
    /**
     * 只有不存在的时候才会插入新数据
     * @param col_name
     * @param fObj
     * @param insert_value
     */
    public async find_insert_unit(col_name: string, fObj: Object = {}, insert_value: any) {
        let db = this.get_unit<any>(col_name, fObj, undefined);
        let s = await db.load();
        if (s.empty) {
            await s.insert(this.merageInfo(insert_value));
        }
        return true;
    }
    public update_insert(col_name: string, fObj: Object = {}, insert_value: any) {
        return this.update(col_name, fObj, insert_value, true);
    }
    /**合并内容 */
    private merageInfo(value: any) {
        let insert_value: any = {};
        for (let key in value) {
            let _keys = key.split('.');
            let _obj = insert_value;
            for (let i = 0; i < _keys.length; i++) {
                let __key = _keys[i];
                if (i == _keys.length - 1) {
                    _obj[__key] = value[key];
                }
                else {
                    if (!_obj[__key])
                        _obj[__key] = {};
                    _obj = _obj[__key];
                }
            }
        }
        return insert_value;
    }
    /**
     * 更新数据
     * @param col_name
     * @param fObj
     * @param value
     * @param insert 如果是 false的时候，数据不存在也返回操作成功
     */
    public async update(col_name: string, fObj: Object = {}, value: any, insert: boolean = false) {
        let db = this.get_unit(col_name, fObj, undefined);
        let s = await db.load();
        if (s.empty) {
            if (insert) {
                // 这里应为什么都没有,需要合并对象
                await s.insert(this.merageInfo(value));
            }
            return true;
        }
        for (let key in value) {
            if (value[key] != s.get(key)) {
                s.set(key, value[key]);
            }
        }
        await s.force_save();
        return true;
    }
    public get_collection(table: string) {
        return this.db.collection(table);
    }
    public get_collection_size(dbname: string, cb: (infos: string) => void) {
        let col = this.db.collection(dbname);
        col.stats((function (_cb: any, err: any, res: any) {
            if (err) {
                _cb('err');
                error(err.toString);
            }
            else {
                _cb(JSON.stringify(res));
            }
        }).bind(this, cb));
    }
    public get_aggregate<T>(dbname: string, pipeline: any[]) {
        return new Promise<T[]>((resolve, reject) => {
            this.db.collection(dbname).aggregate(pipeline, function (err: any, cur: MONGO.AggregationCursor<any>) {
                var outinfos: T[] = [];
                function batchFind() {
                    cur.next(function (_err: MONGO.MongoError, _res: any) {
                        if (_err) {
                            process.nextTick(reject, _err);
                        }
                        else {
                            if (_res == null) {
                                process.nextTick(resolve, outinfos);
                            }
                            else {
                                outinfos.push(_res);
                                process.nextTick(batchFind);
                            }
                        }
                    });
                }
                process.nextTick(batchFind);
            });
        });
    }
    /**
     * 检查和跟新存储函数
     * @param func
     */
    public check_func(func: Function) {
        let _this = this;
        return new Promise<void>(function (resolve, reject) {
            // 先观察方法是否存在
            let fun_name = func.name;
            let dbscript = `db.system.js.save({'_id':'${fun_name}','value':${func.toString()}})`;
            function onSave() {
                _this.eval(dbscript).then(function (result) {
                    // result.retval = {nInserted:0 nMatched:0 nModified:0 nRemoved:0 nUpserted:1}
                    // 一般都是成功的，这里暂时不处理了
                    resolve();
                }).catch(function (err) {
                    reject(err.errmsg);
                });
            }
            _this.eval(fun_name).then(function (result) {
                if (result.retval && result.retval._bsontype == 'Code' && result.retval.code == func.toString()) {
                    // 达成要求了，不需要再操作了
                    resolve();
                }
                else {
                    // 发送命令
                    onSave();
                }
            }).catch(function (e) {
                onSave();
            });
        });
    }
    public call_func(fun_name: string, ...args: (string)[]) {
        let options = {};
        // if (options['nolock']) {
        //     cmd['nolock'] = options['nolock'];
        // }
        for (let i = 0; i < args.length; i++) {
            if (typeof args[i] == 'string') {
                args[i] = '"' + args[i] + '"';
            }
        }
        return this.eval(`${fun_name}(${args.join(',')})`);
    }
    private eval(cmd: string): Promise<{
        ok: number;
        retval: any;
    }> {
        return this.db.command({ '$eval': `${cmd}` });
    }
    public del(table: string, fobj: Object) {
        return this.db.collection(table).deleteMany(fobj);
    }
}
