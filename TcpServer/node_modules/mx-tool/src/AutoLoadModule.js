"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoLoaderModule = void 0;
const events_1 = require("events");
const fs_1 = require("fs");
const path_1 = require("path");
const crypto_1 = require("crypto");
const child_process_1 = require("child_process");
class DirMonitor extends events_1.EventEmitter {
    constructor(path, isFile = false) {
        super();
        this._isFile = false;
        this._isInited = false;
        this._sub_file = new Map();
        this._sub_dri = new Map();
        this._path = path;
        this._isFile = isFile;
        this._isInited = false;
    }
    init() {
        if (this._isInited)
            return;
        this._isInited = true;
        // 先判断是文件夹还是文件
        if (this._isFile) {
            if (this._path.indexOf('.js') == -1) {
                this._path = this._path + '.js';
            }
            this._fsw = fs_1.watch(this._path);
            this._fsw.on("change", this._on_modify.bind(this));
            this._fsw.on("error", this._on_error.bind(this));
            if (fs_1.existsSync(this._path)) {
                let md5 = crypto_1.createHash("md5").update(fs_1.readFileSync(this._path)).digest("hex");
                this._sub_file.set(path_1.parse(this._path).base, md5);
                this.emit("new", this._path);
            }
            return;
        }
        else {
            // 初始化所有文件文件夹
            if (!fs_1.existsSync(this._path)) {
                fs_1.mkdirSync(this._path);
            }
            let files = fs_1.readdirSync(this._path);
            for (let i = 0; i < files.length; i++) {
                let filename = files[i];
                let r_file = path_1.join(this._path, filename);
                let stat = fs_1.statSync(r_file);
                if (stat.isDirectory()) {
                    let mot = new DirMonitor(r_file);
                    mot.on("new", this._pip_event.bind(this, "new"));
                    mot.on("change", this._pip_event.bind(this, "change"));
                    mot.on("del", this._pip_event.bind(this, "del"));
                    mot.init();
                    this._sub_dri.set(filename, mot);
                }
                else {
                    let md5 = crypto_1.createHash("md5").update(fs_1.readFileSync(r_file)).digest("hex");
                    this._sub_file.set(filename, md5);
                    this.emit("new", r_file);
                }
            }
            this._fsw = fs_1.watch(this._path);
            this._fsw.on("change", this._on_modify.bind(this));
            this._fsw.on("error", this._on_error.bind(this));
        }
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    off(event, listener) {
        return super.off(event, listener);
    }
    _pip_event(event, ...args) {
        this.emit(event, ...args);
    }
    _on_error(error) {
        // console.log(error);
        // if (this._watch_files_limit && this._watch_files_limit.indexOf(filename) == -1) return;
    }
    _on_modify(event, filename) {
        let r_path = '';
        if (this._isFile) {
            r_path = this._path;
        }
        else {
            r_path = path_1.join(this._path, filename);
        }
        // 首先判断一下是否存在
        if (!fs_1.existsSync(r_path)) {
            if (this._sub_dri.has(filename)) {
                // 文件夹关闭了那么删除掉目录
                let dir = this._sub_dri.get(filename);
                dir && dir.destory();
                this._sub_dri.delete(filename);
            }
            else if (this._sub_file.has(filename)) {
                this.emit("del", r_path);
                this._sub_file.delete(filename);
            }
        }
        else {
            // 文件存在的,那么需要判断文件夹还是文件
            let stat = fs_1.statSync(r_path);
            if (stat.isDirectory()) {
                // 如果是个文件夹事件,那么就检查一下是否有子文件夹需要监控
                if (!this._sub_dri.has(filename)) {
                    let mot = new DirMonitor(r_path);
                    mot.on("new", this._pip_event.bind(this, "new"));
                    mot.on("change", this._pip_event.bind(this, "change"));
                    mot.on("del", this._pip_event.bind(this, "del"));
                    mot.init();
                    this._sub_dri.set(filename, mot);
                }
            }
            else {
                // 判断一下文件是否需要触发相应
                let md5 = crypto_1.createHash("md5").update(fs_1.readFileSync(r_path)).digest("hex");
                if (!this._sub_file.has(filename)) {
                    // 新增文件
                    this.emit("new", r_path);
                }
                else if (this._sub_file.get(filename) != md5) {
                    // 文件变动
                    this.emit("change", r_path);
                }
                this._sub_file.set(filename, md5);
            }
        }
    }
    destory() {
        this._sub_file.forEach((v, k, m) => {
            this.emit("del", path_1.join(this._path, k));
        });
        this._fsw && this._fsw.close();
        this.removeAllListeners("new");
        this.removeAllListeners("change");
        this.removeAllListeners("del");
        this._sub_dri.forEach((v, k, m) => {
            v.destory();
        });
    }
}
class AutoLoaderModule extends events_1.EventEmitter {
    constructor(dir, option) {
        super();
        this._ModuleCache_ = {};
        this._option = option || {};
        let md = new DirMonitor(dir, this._option.isFile ? true : false);
        md.on("new", this.addModule.bind(this));
        md.on("change", (f) => {
            this.delModule(f);
            this.addModule(f);
        });
        md.on("del", this.delModule.bind(this));
        // md.init();
        this._md = md;
        AutoLoaderModule.cache[dir] = this;
    }
    /**
     * 监听文件夹，加载文件夹中的所有js
     * @param dir
     */
    static watch(dir, option) {
        let tp = this.cache[dir];
        if (!tp) {
            tp = new AutoLoaderModule(dir, option);
            this.cache[dir] = tp;
        }
        return tp;
    }
    /**
     * 开始加载
     */
    load() {
        this._md.init();
        return this;
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    off(event, listener) {
        return super.off(event, listener);
    }
    addModule(filename) {
        // console.log(filename);
        if (this._ModuleCache_.hasOwnProperty(filename)) {
            // console.error('replete file occure', filename);
            return;
        }
        let comp = false;
        let ext = path_1.parse(filename).ext;
        try {
            if (ext == '.js') {
                let __all = require(filename);
                let __pre_all = AutoLoaderModule.del_cache[filename];
                // 看看有什么需要替换的
                if (__pre_all) {
                    for (let key in __all) {
                        __pre_all.exports[key] = __all[key];
                    }
                    delete AutoLoaderModule.del_cache[filename];
                    require.cache[filename] = __pre_all;
                }
            }
            else if (ext == '.ts') {
                // 这里要么黑科技一下 自动编译
                // 暂时不用，可以使用
                if (this._option.tsc) {
                    child_process_1.exec("tsc " + filename, (o) => {
                        // 编译
                        if (o)
                            console.error(o);
                    });
                }
            }
            comp = true;
        }
        catch (e) {
            console.error('load_module[%s]_error[%s]', filename, e);
        }
        if (ext == '.js') {
            this._ModuleCache_[filename] = comp;
            this.emit('add', filename, comp);
        }
    }
    delModule(filename) {
        AutoLoaderModule.del_cache[filename] = require.cache[filename];
        delete this._ModuleCache_[filename];
        delete require.cache[filename];
        this.emit("del", filename, true);
    }
}
exports.AutoLoaderModule = AutoLoaderModule;
AutoLoaderModule.cache = {};
AutoLoaderModule.del_cache = {};
