"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tga_1 = require("./tga");
const taobao_1 = require("./taobao");
const Time_1 = require("../lib/Time");
const timers_1 = require("timers");
const logkit_1 = require("./logkit");
const crypto_1 = require("crypto");
const tganet_1 = require("./tganet");
class LoggerMoudle {
    constructor() {
        // 这里导出日志
        this.keeper = [];
        this.apiTimeout = 3000;
        // 这里实现一个api的记录过程，需要设置一个api的超时事件
        this.genReqID = 0;
        this.baseReqHead = '';
        this.apiMaps = new Map();
    }
    /**
     * 初始化日志模块 支持多个平台同时存在
     * @param plts taobao,logkit,tga
     * @param config 配置信息
     */
    init(plts, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof plts == "string") {
                plts = plts.split(',');
            }
            for (let i = 0; i < plts.length; i++) {
                let plt = plts[i];
                switch (plt) {
                    case "taobao":
                        this.keeper.push(new taobao_1.TaoBaoLogger(config));
                        break;
                    case "logkit":
                        this.keeper.push(new logkit_1.LogKitLogger(config));
                        break;
                    case "tganet":
                        this.keeper.push(new tganet_1.TGALoggerNet(config));
                        break;
                    case "tga":
                        this.keeper.push(new tga_1.TGALogger(config));
                        break;
                    default:
                }
            }
            this.baseReqHead = crypto_1.createHash("md5").update(plts.join(",") + Date.now()).digest("hex");
            for (let i = 0; i < this.keeper.length; i++) {
                yield this.keeper[i].init();
            }
            return true;
        });
    }
    /**
     * 设置默认超时时间
     * @param apiTimeout
     */
    setApiTimeOut(apiTimeout) {
        this.apiTimeout = apiTimeout;
    }
    logEvent(uid, event_name, obj, support_plts) {
        this.keeper.forEach(v => {
            // 考虑某些日志可能只需要记录到特定的平台
            if (support_plts && support_plts.indexOf(v.name) < 0)
                return;
            v.logEvent(uid, event_name, obj);
        });
    }
    logStatic(uid, eventType, obj, support_plts) {
        this.keeper.forEach(v => {
            // 考虑某些日志可能只需要记录到特定的平台
            if (support_plts && support_plts.indexOf(v.name) < 0)
                return;
            v.logStatic(uid, eventType, obj);
        });
    }
    logAPI(api, method, uid, succ, consumeTime, reqID, param, response, support_plts, isShowAll) {
        this.keeper.forEach(v => {
            // 考虑某些日志可能只需要记录到特定的平台
            if (support_plts && support_plts.indexOf(v.name) < 0)
                return;
            if (typeof param != "string") {
                param = JSON.stringify(param);
            }
            if (typeof response != "string") {
                response = JSON.stringify(response);
            }
            v.logApi(api, method, uid, succ, consumeTime, reqID, param, response, isShowAll);
        });
    }
    /**
     * api请求开始
     * @param URI 请求的URL或者URI
     * @param method 请求的方法
     * @param uid 用户id
     * @param param 携带的参数
     * @param reqID 请求id,如果没有的话会自动生成一个
     * @param timeOut 请求的超时市场 默认是3000
     */
    apiBegin(URI, method, uid, param, reqID, timeOut) {
        reqID = reqID || crypto_1.createHash("md5").update(this.baseReqHead + (this.genReqID++)).digest("hex");
        // 这里设置一个超时时间
        let t = timers_1.setTimeout(this.apiEnd.bind(this, reqID, false, undefined, true), timeOut || this.apiTimeout);
        let s = {
            URI: URI,
            method: method,
            uid: (uid || "0").toString(),
            param: param || {},
            begin_time: Date.now(),
            timoutHandle: t
        };
        this.apiMaps.set(reqID, s);
        return reqID;
    }
    /**
     * 收到 api 回值信息
     * @param reqID 请求id
     * @param succ 是否成功
     * @param response 回值内容
     */
    apiEnd(reqID, succ, response, isShowAll) {
        let bInfo = this.apiMaps.get(reqID);
        if (!bInfo)
            return;
        this.apiMaps.delete(reqID);
        timers_1.clearTimeout(bInfo.timoutHandle);
        let cstime = Date.now() - bInfo.begin_time;
        this.logAPI(bInfo.URI, bInfo.method, bInfo.uid, succ || false, cstime, reqID, bInfo.param, response || { code: 408 }, undefined, isShowAll);
    }
    //-------------------------------------------------------------------------------//
    /**
     * 这是一个模板例子，不要使用
     * 玩家注册的时候，发送一份基本数据
     */
    __on_register__(roleID, source, scene) {
        let outList = [];
        let outParam = {
            'sSource': source,
            'sScene': scene
        };
        let ot = this.createLog(roleID, outList, outParam);
        this.logStatic(roleID, 'user_set', ot);
    }
    //------------------------------------------//
    /**
     * 这是一个模板例子，不要使用
     * 用户日志代理接口
     */
    __onLogin__(roleID, event_name, log) {
        // let list = ['sType', 'sSubType', 'sItemId', 'iCount', 'sReason', 'sSubinfo'];
        let param = {};
        for (let key in log) {
            if (log[key] == undefined)
                continue;
            param[key] = (log[key] || "").toString();
        }
        let list = Object.keys(param);
        this.logEvent(roleID, event_name, this.createLog(undefined, list, param));
    }
    //-------------------------------------------------------------------------------//
    /**
     * 有需要的话可以重写这个结构
     * @param role
     * @param arrayList
     * @param outParam
     */
    createLog(role, arrayList = [], outParam = {}) {
        // 有几个是必须要有的添加一下
        let needslist = ['record_time'];
        for (let i = 0; i < needslist.length; i++) {
            if (arrayList.indexOf(needslist[i]) < 0) {
                arrayList.push(needslist[i]);
            }
        }
        // 生成日志的通用接口
        let outLog = {};
        let extList = [];
        for (let key in arrayList) {
            let sKey = arrayList[key];
            switch (sKey) {
                case 'record_time':
                    outLog[sKey] = Time_1.LocalDate.formateString();
                    break;
                default:
                    if (outParam.hasOwnProperty(sKey)) {
                        outLog[sKey] = outParam[sKey];
                    }
                    else {
                        extList.push(sKey);
                    }
                    break;
            }
        }
        return outLog;
    }
}
exports.LoggerMoudle = LoggerMoudle;
LoggerMoudle.types = {
    taobao: "taobao",
    logkit: "logkit",
    tga: "tga",
    tganet: "tganet"
};
//# sourceMappingURL=index.js.map