"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReSubHash = exports.ReHash = void 0;
const Util_1 = require("../lib/Util");
class ReHash {
    constructor(parent, fObj, judgefunc, args) {
        this.fObj = {};
        this._data_ = {};
        this._online_ = false;
        this.ready = false;
        this._changeKey = [];
        this._auto_save = 0;
        this._onload = [];
        this._bind_auto_save = this.auto_save.bind(this);
        this.fObj = Util_1.Util.copy(fObj);
        this._data_ = Util_1.Util.copy(fObj);
        this.args = args;
        this._collection_ = parent;
        this._jugetfunc = judgefunc;
    }
    get findKey() {
        return this.fObj;
    }
    setObjectID(objID, v) {
        this._data_ = Object.assign(this._data_ || {}, { _id: objID }, this.findKey, v || {});
    }
    force_ok() {
        this._online_ = this._data_._id ? true : false;
    }
    insert(v) {
        return new Promise((resolve, reject) => {
            // 这里把强制的 findkey 也复制上去
            v = Util_1.Util.attach(v, this.findKey);
            this._collection_.insertOne(v, (err, res) => {
                if (err)
                    reject(err);
                else {
                    if (this._online_) {
                        if (res.result.ok && res.ops.length) {
                            this._data_ = res.ops[0];
                        }
                    }
                    resolve();
                }
            });
        });
    }
    /**
     * 返回的都是 拷贝项，变更都要主动set
     * @param key
     */
    get(key) {
        if (!this._data_)
            return null;
        return Util_1.Util.copy(this._get(key));
    }
    _get(key) {
        let sKey = key.split('.');
        let obj = this._data_;
        for (let i = 0; i < sKey.length; i++) {
            let oneKey = sKey[i];
            if (i == sKey.length - 1) {
                return obj[oneKey];
            }
            else if (!obj.hasOwnProperty(oneKey)) {
                break;
            }
            else {
                obj = obj[oneKey];
            }
        }
        return undefined;
    }
    _set(key, value) {
        let sKey = key.split('.');
        let obj = this._data_;
        for (let i = 0; i < sKey.length; i++) {
            let oneKey = sKey[i];
            if (i == sKey.length - 1) {
                if (obj[oneKey] == value)
                    return false;
                if (value == undefined || value == null) {
                    delete obj[oneKey];
                }
                else {
                    obj[oneKey] = value;
                }
            }
            else {
                if (!obj.hasOwnProperty(oneKey)) {
                    obj[oneKey] = {};
                }
                obj = obj[oneKey];
            }
        }
        return true;
    }
    set(key, value) {
        if (!this._online_)
            return;
        if (this.findKey.hasOwnProperty(key))
            return;
        // 如果当前数据是空的，表示之前是没有这个数据的，需要把查询头加上
        if (!this._data_) {
            this._data_ = Util_1.Util.attach({}, this.findKey);
            this._collection_.insertOne(this._data_);
        }
        if (this._get(key) == value)
            return;
        this._set(key, value);
        this.flag(key);
    }
    mset(a) {
        for (var i = 0; i < a.length; i++)
            this.set(a[i].k, a[i].v);
    }
    /**
     * 按照一个key 一个 value的方式传入参数
     * @param args
     */
    lset(...args) {
        let count = Math.ceil(args.length / 2);
        for (let i = 0; i < count; i++) {
            this.set(args[i * 2], args[i * 2 + 1]);
        }
    }
    /**
     * 标记一个字段需要重新保存一下
     * @param key
     */
    flag(key) {
        // 这里要做一下合并
        if (this._changeKey.indexOf(key) < 0)
            this._changeKey.push(key);
        this._check_save();
    }
    _check_save() {
        if (!this._data_ || this._auto_save)
            return;
        this._auto_save = setTimeout(this._bind_auto_save, 1000);
    }
    /**
     * 立即保存数据到数据库
     */
    force_save() {
        if (this._auto_save)
            clearTimeout(this._auto_save);
        return this.auto_save();
    }
    mergeKeys() {
        // 这里合并一下子
        let list = this._changeKey.sort(function (a, b) {
            if (a.length != b.length) {
                return a.length > b.length ? 1 : -1;
            }
            if (a == b) {
                return 0;
            }
            return a > b ? 1 : -1;
        });
        let result = [];
        for (let i = 0; i < list.length; i++) {
            let key = list[i];
            let mList = key.split('.');
            if (mList.length > 1) {
                // 这里需要判断合并
                let find = false;
                for (let i = 0; i < mList.length; i++) {
                    if (result.indexOf(mList.slice(0, i + 1).join('.')) >= 0) {
                        // 表示存在了高级货了那么就不需要处理了
                        find = true;
                        break;
                    }
                }
                if (find)
                    continue;
            }
            result.push(key);
        }
        this._changeKey = result;
    }
    auto_save() {
        return __awaiter(this, void 0, void 0, function* () {
            this._auto_save = 0;
            if (!this._data_)
                return true;
            var sets = {};
            var unsets = {};
            this.mergeKeys();
            for (var i = 0; i < this._changeKey.length; i++) {
                let ckey = this._changeKey[i];
                let cvalue = this._get(ckey);
                if (cvalue == null || cvalue == undefined) {
                    unsets[ckey] = 1;
                }
                else {
                    sets[ckey] = cvalue;
                }
            }
            this._changeKey = [];
            var up_info = {};
            if (Object.keys(sets).length > 0) {
                up_info['$set'] = sets;
            }
            if (Object.keys(unsets).length > 0) {
                up_info['$unset'] = unsets;
            }
            // 拷贝一下 _id 防止更新错数据
            if (!this.findKey['_id'] && this._data_['_id']) {
                this.findKey['_id'] = this._data_['_id'];
            }
            if (Object.keys(up_info).length > 0) {
                return this._collection_.updateOne(this.findKey, up_info);
            }
            return true;
        });
    }
    _doLoadReslove() {
        this._onload.forEach(v => {
            v.r(this);
        });
        this._onload.splice(0, this._onload.length);
    }
    _doLoadReject(e) {
        this._onload.forEach(v => {
            v.j(e);
        });
        this._onload.splice(0, this._onload.length);
    }
    reload(filter, sort) {
        this._online_ = false;
        return this.load(filter, sort);
    }
    /**
     * 从数据库加载数据 如果加载中同时发起了多次这里实际只有一次发起加载
     * @param fitle
     */
    load(filter, sort) {
        return new Promise((r, j) => __awaiter(this, void 0, void 0, function* () {
            this._onload.push({ r: r, j: j });
            // 缓存起来
            if (this._online_) {
                if (!this.ready) {
                    // 加载中但是没有加载完成的时候二次调用那么就跳过加载发起流程
                    return;
                }
                else {
                    // 表示我要自己直接调用了，就不用再考虑我了
                    this._onload.pop();
                    r(this);
                    return;
                }
            }
            try {
                this.ready = false;
                this._online_ = true;
                // 外网出现数据重复的情况，这里需要优化一下
                let _cc_ = this._collection_.find(this.findKey, { projection: filter, sort: sort });
                let _judge_list = [];
                function batchFind() {
                    _cc_.next((err, result) => {
                        if (err) {
                            this._doLoadReject(err);
                        }
                        else if (result == null) {
                            process.nextTick(this._on_load.bind(this), _judge_list);
                        }
                        else {
                            _judge_list.push(result);
                            process.nextTick(batchFind.bind(this));
                        }
                    });
                }
                batchFind.apply(this);
            }
            catch (e) {
                this._doLoadReject(e);
            }
        }));
    }
    /**
     * 是否是空数据
     */
    get empty() {
        if (this._data_)
            return false;
        return true;
    }
    // 获取原始数据 如果改动的话会造成 set函数失败
    get data() {
        return this._data_;
    }
    // 深拷贝一份数据
    clone() {
        return Util_1.Util.copy(this._data_);
    }
    // 获取一个复制后的数据备份
    get value() {
        var ot = this.clone();
        delete ot['_id'];
        return ot;
    }
    // 获取一个保函 _id 的数据备份
    get value_all() {
        return this.clone();
    }
    /**
     * 删除某个字段
     * @param key
     */
    del(key) {
        if (key instanceof Array) {
            for (var i = 0; i < key.length; i++)
                this.set(key[i], undefined);
        }
        else {
            this.set(key, undefined);
        }
    }
    /**
     * 删除当前数据
     */
    remove() {
        if (!this._online_)
            return;
        this._collection_.deleteOne({ _id: this._data_._id });
    }
    _on_load(data) {
        this.ready = true;
        if (data.length == 1) {
            this._data_ = data[0] || null;
            this._doLoadReslove();
        }
        else if (data.length == 0) {
            this._data_ = null;
            this._doLoadReslove();
        }
        else {
            // 这里需要竞争一下，出现重复数据了
            if (this._jugetfunc) {
                //如果有排序的话使用自定义的，否则是用id较小的 
                data.sort(this._jugetfunc);
            }
            else {
                data.sort(function (a, b) {
                    return a['_id'] < b['_id'] ? -1 : 1;
                });
            }
            this._data_ = data[0];
            this._doLoadReslove();
        }
    }
}
exports.ReHash = ReHash;
// 这里基于ReHash 增加一个 SubHash的 这个hash的来源是 ReHash中的一部分内容 通过filter提取的
class ReSubHash extends ReHash {
    constructor(parent, fObj, head, judgefunc, args) {
        super(parent, fObj, judgefunc, args);
        // 筛选用的字段，默认在保存操作的时候需要发挥作用
        this.fitler = {};
        this.head = "";
        this.fitler[head] = 1;
        this.head = head;
        // this.fitlerString.push(...Object.keys(this.fitler))
    }
    // 理论上是存在 empty的情况，所以需要处理一下
    get data() {
        if (!this._data_)
            return undefined;
        return this._data_[this.head];
    }
    // 理论上是存在 empty的情况，所以需要处理一下
    get value() {
        if (!this._data_)
            return undefined;
        return Util_1.Util.copy(this._data_[this.head]);
        ;
    }
    // 理论上是存在 empty的情况，所以需要处理一下
    get value_all() {
        return this.value;
    }
    // 这里增加一个过滤内容，在key上要求满足fitler中的一项
    set(key, value) {
        return super.set(this.head + "." + key, value);
    }
    load(sort) {
        const _super = Object.create(null, {
            load: { get: () => super.load }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.load.call(this, this.fitler, sort);
            return this;
        });
    }
    insert(v) {
        super.set(this.head, v);
        return this.force_save();
    }
    // 一般来说filter只会是一项的
    get empty() {
        if (!this._data_)
            return true;
        if (this._get(this.head) == undefined) {
            return true;
        }
        return false;
    }
}
exports.ReSubHash = ReSubHash;
// 这里提供一个装饰器来支持自动存取数据和操作数据
//# sourceMappingURL=ReHash.js.map