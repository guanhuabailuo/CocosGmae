import { Util } from "../lib/Util"
import MONGO from "mongodb"

export class ReHash<T> {
    protected fObj: Object = {};
    public args: any;
    protected _collection_: MONGO.Collection;
    protected _data_: any = {};
    protected _online_: boolean = false;
    protected _bind_auto_save: Function;
    public ready = false;
    get findKey() {
        return this.fObj as any;
    }
    protected _jugetfunc: ((a: T, b: T) => number) | undefined;
    setObjectID(objID: object, v: any) {
        this._data_ = Object.assign(this._data_ || {}, { _id: objID }, this.findKey, v || {});
    }
    constructor(parent: MONGO.Collection, fObj: Object, judgefunc: ((a: T, b: T) => number) | undefined, args: any) {
        this._bind_auto_save = this.auto_save.bind(this);
        this.fObj = Util.copy(fObj);
        this._data_ = Util.copy(fObj);
        this.args = args;
        this._collection_ = parent;
        this._jugetfunc = judgefunc;
    }
    force_ok() {
        this._online_ = this._data_._id ? true : false;
    }
    insert(v: T) {
        return new Promise<void>((resolve, reject) => {
            // 这里把强制的 findkey 也复制上去
            v = Util.attach(v, this.findKey);
            this._collection_.insertOne(v, (err: any, res: {
                ops: T[];
                result: {
                    n: number;
                    ok: number;
                };
            }) => {
                if (err)
                    reject(err);
                else {
                    if (this._online_) {
                        if (res.result.ok && res.ops.length) {
                            this._data_ = res.ops[0];
                        }
                    }
                    resolve();
                }
            });
        });
    }
    /**
     * 返回的都是 拷贝项，变更都要主动set
     * @param key
     */
    get(key: string) {
        if (!this._data_)
            return null;
        return Util.copy(this._get(key)) as any;
    }
    protected _changeKey: string[] = [];
    protected _get(key: string) {
        let sKey = key.split('.');
        let obj = this._data_;
        for (let i = 0; i < sKey.length; i++) {
            let oneKey = sKey[i];
            if (i == sKey.length - 1) {
                return obj[oneKey];
            }
            else if (!obj.hasOwnProperty(oneKey)) {
                break;
            }
            else {
                obj = obj[oneKey];
            }
        }
        return undefined;
    }
    protected _set(key: string, value: any) {
        let sKey = key.split('.');
        let obj = this._data_;
        for (let i = 0; i < sKey.length; i++) {
            let oneKey = sKey[i];
            if (i == sKey.length - 1) {
                if (obj[oneKey] == value)
                    return false;
                if (value == undefined || value == null) {
                    delete obj[oneKey];
                }
                else {
                    obj[oneKey] = value;
                }
            }
            else {
                if (!obj.hasOwnProperty(oneKey)) {
                    obj[oneKey] = {};
                }
                obj = obj[oneKey];
            }
        }
        return true;
    }
    set(key: string, value: any) {
        if (!this._online_)
            return;
        if (this.findKey.hasOwnProperty(key))
            return;
        // 如果当前数据是空的，表示之前是没有这个数据的，需要把查询头加上
        if (!this._data_) {
            this._data_ = Util.attach({}, this.findKey);
            this._collection_.insertOne(this._data_);
        }
        if (this._get(key) == value)
            return;
        this._set(key, value);
        this.flag(key);
    }
    mset(a: {
        k: string;
        v: any;
    }[]) {
        for (var i = 0; i < a.length; i++)
            this.set(a[i].k, a[i].v);
    }
    /**
     * 按照一个key 一个 value的方式传入参数
     * @param args
     */
    lset(...args: any[]) {
        let count = Math.ceil(args.length / 2);
        for (let i = 0; i < count; i++) {
            this.set(args[i * 2], args[i * 2 + 1]);
        }
    }
    /**
     * 标记一个字段需要重新保存一下
     * @param key
     */
    flag(key: string) {
        // 这里要做一下合并
        if (this._changeKey.indexOf(key) < 0)
            this._changeKey.push(key);

        this._check_save();
    }
    protected _auto_save: number = 0;
    protected _check_save() {
        if (!this._data_ || this._auto_save)
            return;
        this._auto_save = setTimeout(this._bind_auto_save, 1000);
    }
    /**
     * 立即保存数据到数据库
     */
    force_save() {
        if (this._auto_save)
            clearTimeout(this._auto_save);
        return this.auto_save();
    }

    private mergeKeys() {
        // 这里合并一下子
        let list = this._changeKey.sort(function (a, b) {
            if (a.length != b.length) {
                return a.length > b.length ? 1 : -1
            }

            if (a == b) {
                return 0;
            }

            return a > b ? 1 : -1
        });

        let result: string[] = []
        for (let i = 0; i < list.length; i++) {
            let key = list[i];
            let mList = key.split('.')
            if (mList.length > 1) {
                // 这里需要判断合并
                let find = false;
                for (let i = 0; i < mList.length; i++) {
                    if (result.indexOf(mList.slice(0, i + 1).join('.')) >= 0) {
                        // 表示存在了高级货了那么就不需要处理了
                        find = true;
                        break;
                    }
                }
                if (find) continue;
            }

            result.push(key);
        }

        this._changeKey = result;
    }

    protected async auto_save() {
        this._auto_save = 0;
        if (!this._data_)
            return true;
        var sets: any = {};
        var unsets: any = {};
        this.mergeKeys();
        for (var i = 0; i < this._changeKey.length; i++) {
            let ckey = this._changeKey[i];
            let cvalue = this._get(ckey);
            if (cvalue == null || cvalue == undefined) {
                unsets[ckey] = 1;
            }
            else {
                sets[ckey] = cvalue;
            }
        }
        this._changeKey = [];
        var up_info: any = {};
        if (Object.keys(sets).length > 0) {
            up_info['$set'] = sets;
        }
        if (Object.keys(unsets).length > 0) {
            up_info['$unset'] = unsets;
        }
        // 拷贝一下 _id 防止更新错数据
        if (!this.findKey['_id'] && this._data_['_id']) {
            this.findKey['_id'] = this._data_['_id'];
        }
        if (Object.keys(up_info).length > 0) {
            return this._collection_.updateOne(this.findKey, up_info) as Promise<any>;
        }
        return true;
    }

    private _onload: { r: Function, j: Function }[] = []

    private _doLoadReslove() {
        this._onload.forEach(v => {
            v.r(this);
        })

        this._onload.splice(0, this._onload.length);
    }

    private _doLoadReject(e: any) {
        this._onload.forEach(v => {
            v.j(e);
        })

        this._onload.splice(0, this._onload.length);
    }

    reload(filter?: any, sort?: any) {
        this._online_ = false;
        return this.load(filter, sort);
    }

    /**
     * 从数据库加载数据 如果加载中同时发起了多次这里实际只有一次发起加载
     * @param fitle
     */
    load(filter?: any, sort?: any): Promise<ReHash<T>> {
        return new Promise<ReHash<T>>(async (r, j) => {
            this._onload.push({ r: r, j: j });
            // 缓存起来
            if (this._online_) {
                if (!this.ready) {
                    // 加载中但是没有加载完成的时候二次调用那么就跳过加载发起流程
                    return;
                }
                else {
                    // 表示我要自己直接调用了，就不用再考虑我了
                    this._onload.pop();
                    r(this)
                    return;
                }
            }

            try {
                this.ready = false;
                this._online_ = true;
                // 外网出现数据重复的情况，这里需要优化一下
                let _cc_ = this._collection_.find(this.findKey, { projection: filter, sort: sort });
                let _judge_list: any[] = [];
                function batchFind(this: ReHash<T>) {
                    _cc_.next((err, result) => {
                        if (err) {
                            this._doLoadReject(err);
                        }
                        else if (result == null) {
                            process.nextTick(this._on_load.bind(this), _judge_list);
                        }
                        else {
                            _judge_list.push(result);
                            process.nextTick(batchFind.bind(this));
                        }
                    });
                }
                batchFind.apply(this);
            }
            catch (e) {
                this._doLoadReject(e);
            }
        });
    }
    /**
     * 是否是空数据
     */
    get empty() {
        if (this._data_)
            return false;
        return true;
    }
    // 获取原始数据 如果改动的话会造成 set函数失败
    get data() {
        return this._data_ as T;
    }
    // 深拷贝一份数据
    clone() {
        return Util.copy(this._data_) as T;
    }
    // 获取一个复制后的数据备份
    get value(): T {
        var ot: any = this.clone();
        delete ot['_id'];
        return ot;
    }
    // 获取一个保函 _id 的数据备份
    get value_all(): T {
        return this.clone();
    }
    /**
     * 删除某个字段
     * @param key
     */
    del(key: string | string[]) {
        if (key instanceof Array) {
            for (var i = 0; i < key.length; i++)
                this.set(key[i], undefined);
        }
        else {
            this.set(key, undefined);
        }
    }
    /**
     * 删除当前数据
     */
    remove() {
        if (!this._online_)
            return;
        this._collection_.deleteOne({ _id: this._data_._id });
    }
    protected _on_load(data: T[]) {
        this.ready = true;
        if (data.length == 1) {
            this._data_ = data[0] || null;
            this._doLoadReslove();
        }
        else if (data.length == 0) {
            this._data_ = null;
            this._doLoadReslove();
        }
        else {
            // 这里需要竞争一下，出现重复数据了
            if (this._jugetfunc) {
                //如果有排序的话使用自定义的，否则是用id较小的 
                data.sort(this._jugetfunc);
            }
            else {
                data.sort(function (a: T | any, b: T | any) {
                    return a['_id'] < b['_id'] ? -1 : 1;
                });
            }
            this._data_ = data[0];
            this._doLoadReslove();
        }
    }
}


// 这里基于ReHash 增加一个 SubHash的 这个hash的来源是 ReHash中的一部分内容 通过filter提取的
export class ReSubHash<T> extends ReHash<T> {
    // 筛选用的字段，默认在保存操作的时候需要发挥作用
    protected fitler: any = {};
    protected head: string = "";
    constructor(parent: MONGO.Collection, fObj: Object, head: string, judgefunc: ((a: T, b: T) => number) | undefined, args: any) {
        super(parent, fObj, judgefunc, args);
        this.fitler[head] = 1;
        this.head = head;
        // this.fitlerString.push(...Object.keys(this.fitler))
    }

    // 理论上是存在 empty的情况，所以需要处理一下
    get data(): T {
        if (!this._data_) return undefined as any;
        return this._data_[this.head]
    }

    // 理论上是存在 empty的情况，所以需要处理一下
    get value(): T {
        if (!this._data_) return undefined as any;
        return Util.copy(this._data_[this.head]) as T;;
    }

    // 理论上是存在 empty的情况，所以需要处理一下
    get value_all(): T {
        return this.value;
    }

    // 这里增加一个过滤内容，在key上要求满足fitler中的一项
    set(key: string, value: any) {
        return super.set(this.head + "." + key, value)
    }

    async load(sort?: any) {
        await super.load(this.fitler, sort);
        return this;
    }

    insert(v: T) {
        super.set(this.head, v);
        return this.force_save();
    }

    // 一般来说filter只会是一项的
    get empty() {
        if (!this._data_) return true;
        if (this._get(this.head) == undefined) {
            return true
        }

        return false;
    }
}


// 这里提供一个装饰器来支持自动存取数据和操作数据
