"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadModule = exports.InitMoudle = void 0;
const debug_1 = require("debug");
const Time_1 = require("./Time");
const fs_1 = require("fs");
const path_1 = require("path");
let Debug = debug_1.debug('server-libs');
/*提供一个加载流程，如果某一个步骤失败的话，会等待一定时间后重新调用，知道成功为止*/
class InitMoudle {
    static regist(caller, func, ...args) {
        this.initLoad.push({
            func: func,
            args: args,
            caller: caller
        });
    }
    static wait(num) {
        return new Promise(function (resolve) {
            setTimeout(() => {
                resolve();
            }, num);
        });
    }
    static startApp() {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                try {
                    yield this.doWork();
                    break;
                }
                catch (e) {
                    let unit = this.initLoad[this.initStep];
                    console.log(`init failed at step ${this.initStep} <${unit.caller.name}> wait ${this.initWait / 1000}s to reinit`);
                    e && Debug('error', e);
                }
                finally {
                    yield this.wait(this.initWait);
                }
            }
            return true;
        });
    }
    static doWork() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this.initLoad.length; i++) {
                let unit = this.initLoad[i];
                if (this.checkStep(i)) {
                    yield unit.func.apply(unit.caller, unit.args);
                    console.log(`${unit.caller.name} init ok at Time`, Time_1.LocalDate.formateString());
                    this.setStep(i + 1);
                }
            }
            return true;
        });
    }
    static checkStep(num) {
        if (num == this.initStep)
            return true;
        return false;
    }
    static setStep(num) {
        this.initStep = Math.max(this.initStep, num);
        return true;
    }
}
exports.InitMoudle = InitMoudle;
InitMoudle.initLoad = [];
InitMoudle.initStep = 0;
InitMoudle.initWait = 3000;
function loadModule(dirName, initFn) {
    let loadSet = new Set();
    let files = fs_1.readdirSync(dirName);
    for (let i = 0; i < files.length; i++) {
        let fpath = path_1.join(dirName, files[i]);
        let pPath = path_1.parse(fpath);
        let modName = path_1.join(pPath.dir, pPath.name);
        // 给每个rpc初始化一下
        try {
            if (loadSet.has(modName))
                continue;
            let rpcmod = require(modName);
            if (initFn) {
                initFn(modName, rpcmod);
            }
            loadSet.add(modName);
        }
        catch (e) {
        }
    }
    let result = [];
    loadSet.forEach((v1, v2) => {
        result.push(v1.replace(dirName, ""));
    });
    return result;
}
exports.loadModule = loadModule;
