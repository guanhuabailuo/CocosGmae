import { NextFunction, Request, Response } from "express";
import { IncomingHttpHeaders } from "http";
import { join, parse, sep } from "path";


function parseErrorLine(err: Error) {
    if (!err || !(err instanceof Error) || !err.stack) {
        return '[-]'
    }

    const stack = err.stack;
    const stackArr = stack.split('\n');
    let callerLogIndex = (stackArr.length > 0) ? 1 : 0;
    // for (let i = 0; i < stackArr.length; i++) {
    //     if (stackArr[i].indexOf('makeError') > 0 && i + 1 < stackArr.length) {
    //         callerLogIndex = i + 1;
    //         break;
    //     }
    // }

    if (callerLogIndex !== 0) {
        const callerStackLine = stackArr[callerLogIndex] as string;
        let list = callerStackLine.split(/\(|\)/)
        if (list[1] && list[1].length > 0) {
            return `[${list[1].replace(process.cwd(), '').replace(/\\/g, "/").replace('/', '')}]`
        }
        else {
            return `[${callerStackLine.substring(callerStackLine.lastIndexOf(sep) + 1, callerStackLine.lastIndexOf(':'))}]`;
        }
    } else {
        return '[-]';
    }
}

export interface RequestEx extends Request {
    responseData: any
}

export type SeParamConfigType = "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol"

interface ifParamCheckConfig { [name: string]: { type: SeParamConfigType, required: boolean, change: boolean } }
interface TypedPropertyDescriptorEx<T> extends TypedPropertyDescriptor<T> {
    params?: ifParamCheckConfig
}


class HandleUnit {
    symbol: symbol
    constructor(symbol?: symbol) {
        this.symbol = symbol || Symbol()
    }

    routeMap: {
        [f: string]: {
            target: any;
            value: (param: { [x: string]: any }, method: string, headers: IncomingHttpHeaders, req?: RequestEx) => Promise<any>;
            params: ifParamCheckConfig
        }
    } = {};
    beforeList: {
        target: any;
        params: ifParamCheckConfig,
        value: (req: Request, res: Response) => any
    }[] = []
    afterList: {
        target: any;
        value: (req: Request, res: Response) => any
        params: ifParamCheckConfig,
    }[] = []


    paramsCheck(checkMap: ifParamCheckConfig, params: { [x: string]: any }) {
        if (checkMap == undefined) return;

        for (let key in checkMap) {
            let cfg = checkMap[key];
            if (cfg.required && !params.hasOwnProperty(key)) {
                // 这里没找到 抛出一个异常
                throw Error(`param [${key} required and type limit ${cfg.type}]`)
            }
            else if (!params.hasOwnProperty(key)) {
                continue;
            }

            if (cfg.type == typeof params[key]) {
                continue
            }

            // 这里类型不同
            if (!cfg.change) {
                throw Error(`param [${key} type limit ${cfg.type}]`)
            }
            else {
                switch (cfg.type) {
                    case "bigint": params[key] = BigInt(params[key]); break;
                    case "boolean": {
                        if (params[key] == true || params[key] == "true") {
                            params[key] = true;
                        }
                        else {
                            params[key] = false;
                        }
                        // params[key] = Boolean(params[key]);
                        break;
                    }
                    case "function": throw Error(`param [${key} type limit ${cfg.type}]`);
                    case "number": params[key] = Number(params[key]);
                        // 这里增加一个小优化 ，如果是整数那么直接转换成整数
                        if (params[key] = parseInt(params[key])) {
                            params[key] = parseInt(params[key])
                        }
                        break;
                    case "object": params[key] = JSON.parse(params[key].toString()); break;
                    case "string": params[key] = String(params[key]); break;
                    case "symbol": params[key] = Symbol(params[key]); break;
                    default: break;
                }
            }
        }
    }

    // 调用接口
    getRouteFunc(Name: string, req: RequestEx) {
        let routeObj = this.routeMap[Name];
        if (!routeObj) {
            return undefined;
        }
        this.paramsCheck(routeObj.params, req.params)
        return routeObj.value.bind(routeObj.target, req.params, req.method.toUpperCase(), req.headers, req)
    }

    /**
     * 调用模块
     * @param pathlist 
     * @param req 
     * @param res 
     * @param next 
     */
    async route(Name: string, req: RequestEx, res: Response, next: NextFunction) {
        try {
            let routeFunc = this.getRouteFunc(Name, req)
            if (!routeFunc) {
                req.responseData = {
                    code: -1,
                    errMsg: "can not find [" + req.path + "]"
                }
                return true;
            }

            // 这里开始调用响应
            req.responseData = await routeFunc()
            if (req.responseData == undefined) {
                req.responseData = { code: 0 }
            }
        }
        catch (e) {
            if (!e) {
                req.responseData = {
                    code: -1,
                    errMsg: "error bug no message"
                }
            }
            else if (typeof e == 'string') {
                req.responseData = e
            }
            else if (e instanceof Error) {
                req.responseData = {
                    code: -1,
                    errMsg: e.message,
                    __line__: parseErrorLine(e)
                }
            }
            else {
                req.responseData = e;
            }
        }

        return true
    }
    /**
    * 调用模块
    * @param pathlist 
    * @param req 
    * @param res 
    * @param next 
    */
    async before(req: RequestEx, res: Response) {
        for (let i = 0; i < this.beforeList.length; i++) {
            let routeMap = this.beforeList[i];
            try {
                this.paramsCheck(routeMap.params, req.params);
                await routeMap.value.apply(routeMap.target, [req, res]);
            }
            catch (e) {
                // 出钱异常的化
                if (!e) {
                    req.responseData = {
                        code: -1,
                        errMsg: "error bug no message"
                    }
                }
                else if (typeof e == 'string') {
                    req.responseData = e
                }
                else if (e instanceof Error) {
                    req.responseData = {
                        code: -1,
                        errMsg: e.message,
                        __line__: parseErrorLine(e)
                    }
                }
                else {
                    req.responseData = e;
                }
                return false
            }
        }
        return true
    }
    /**
    * 调用模块
    * @param pathlist 
    * @param req 
    * @param res 
    * @param next 
    */
    async after(req: RequestEx, res: Response) {
        for (let i = 0; i < this.afterList.length; i++) {
            let routeMap = this.afterList[i];
            try {
                this.paramsCheck(routeMap.params, req.params);
                await routeMap.value.apply(routeMap.target, [req, res]);
            }
            catch (e) {
                // 出钱异常的化
                if (!e) {
                    req.responseData = {
                        code: -1,
                        errMsg: "error bug no message"
                    }
                }
                else if (typeof e == 'string') {
                    req.responseData = e
                }
                else if (e instanceof Error) {
                    req.responseData = {
                        code: -1,
                        errMsg: e.message,
                        __line__: parseErrorLine(e)
                    }
                }
                else {
                    req.responseData = e;
                }
                return false
            }
        }
        return true
    }
}

class HandleMap {
    private routeMap: { [f: string]: HandleUnit } = {};
    private currNode: HandleUnit | undefined;
    private type: string;
    private mainPath: string | undefined;
    constructor(type: "route" | "env" | "global") {
        this.type = type;
    }

    mergeModule(fileRoute: string) {
        // this.routeMap[prePath].routeMap = Object.assign(this.routeMap[prePath].routeMap, this.currNode.routeMap)
        // if (this.currNode.afterList) this.routeMap[prePath].afterList.push(...this.currNode.afterList)
        // if (this.currNode.beforeList) this.routeMap[prePath].beforeList.push(...this.currNode.beforeList)

        for (let key in this.routeMap) {
            let file = key;
            let mmap = this.routeMap[key]
            // 判断一下是全路径的还是相对地址的
            if (file.indexOf(fileRoute) < 0) continue
            // 这里改成相对地址的模块
            let nKey = key.replace(fileRoute, "/");
            let n = this.getModule(nKey)
            n.routeMap = Object.assign(mmap.routeMap, n.routeMap)
            if (mmap.afterList) n.afterList.push(...mmap.afterList)
            if (mmap.beforeList) n.beforeList.push(...mmap.beforeList)
            delete this.routeMap[key]
        }
        this.mainPath = fileRoute;
    }

    hasModule(prePath: string) {
        if (this.routeMap[prePath]) true;
        return false;
    }

    private formateRoute(prePath: string) {
        prePath = prePath.replace(/\\/g, "/")
        if (this.mainPath) {
            prePath = prePath.replace(this.mainPath, "/")
        }

        prePath = prePath.replace(/\/\//g, "/")
        if (prePath == undefined || prePath == null || prePath == "") prePath = "/";
        if (prePath[0] != "/") prePath = "/" + prePath
        // if (prePath.charAt(0) != "/") prePath = "/" + prePath;

        return prePath;
    }

    getModule(prePath: string) {
        prePath = this.formateRoute(prePath)

        if (!this.routeMap[prePath]) this.routeMap[prePath] = new HandleUnit()
        return this.routeMap[prePath]
    }

    private _chechMethod(target: any) {
        if (!this.currNode) this.currNode = new HandleUnit()
        if (!target.___symbol) target.___symbol = this.currNode.symbol;
        if (target.___symbol != this.currNode.symbol) {
            // 表示注册的不是当前class的模块了，需要替换
            this.currNode = new HandleUnit
        }
    }

    /**
     * 设置模块的归属
     */
    class(prePath?: string | NodeModule): ClassDecorator {
        return (target) => {
            if (prePath == undefined) prePath = target.name
            if (typeof prePath != "string") {
                let pd = parse(prePath.filename);
                if (pd.name == "index") {
                    prePath = pd.dir;
                }
                else {
                    prePath = join(pd.dir, pd.name)
                }
            }

            prePath = this.formateRoute(prePath);

            if (!this.currNode) return;
            // 这里负责把当前注册的节点添加到目标节点库中
            if (this.routeMap[prePath]) {
                // 这里需要合并
                this.routeMap[prePath].routeMap = Object.assign(this.routeMap[prePath].routeMap, this.currNode.routeMap)
                if (this.currNode.afterList) this.routeMap[prePath].afterList.push(...this.currNode.afterList)
                if (this.currNode.beforeList) this.routeMap[prePath].beforeList.push(...this.currNode.beforeList)
                this.currNode = undefined;
            }
            else {
                this.routeMap[prePath] = this.currNode;
                this.currNode = undefined
            }
        }
    }

    methodPrepare(descriptor: TypedPropertyDescriptorEx<any>) {
        if (!descriptor.params) descriptor.params = {};
    }

    /**
    * 注册路由
    */
    route(Name?: string): MethodDecorator {
        return (target, name, descriptor) => {
            this._chechMethod(target)
            this.methodPrepare(descriptor)
            if (Name == undefined && typeof name == "string") Name = name;
            if (Name == undefined || descriptor.value == undefined) return;
            if (this.currNode) this.currNode.routeMap[Name] = {
                target: target,
                value: descriptor.value as any,
                params: (descriptor as any).params
            }
        }
    }

    /**
    * 检查路由参数 如果调用了那么就给这个函数增加一个参数检查的标识，否则就不处理
    */
    params(pName: string, pType: SeParamConfigType, required: boolean, change: boolean): MethodDecorator {
        return (target, name, descriptor: TypedPropertyDescriptorEx<any>) => {
            this.methodPrepare(descriptor)
            this._chechMethod(target)
            if (!this.currNode || !descriptor.params) {
                // 理论上不会进入这里的
                return;
            }
            if (typeof name == "string") {
                descriptor.params[pName] = { type: pType, required: required, change: change }
            }
            else {
                // 这里如果传入的是 symbol 那么就比较难受了
                console.warn(`params check error on func ${name.toString()} ${pName} ${pType}`)
            }
        }
    }

    /**
     * 模块方法调用前的调用，主要是给数据处理提供前置准备
     */
    before(): MethodDecorator {
        return (target, name, descriptor: TypedPropertyDescriptorEx<any>) => {
            this.methodPrepare(descriptor)
            this._chechMethod(target)
            if (descriptor.value && this.currNode) this.currNode.beforeList.push({
                target: target,
                params: descriptor.params || {},
                value: descriptor.value
            })
        }
    }

    /**
     * 模块方法调用后调用，主要是给数据处理提供最后的操作
     */
    after(): MethodDecorator {
        return (target, name, descriptor: TypedPropertyDescriptorEx<any>) => {
            this.methodPrepare(descriptor)
            this._chechMethod(target)
            if (descriptor.value && this.currNode) this.currNode.afterList.push({
                target: target,
                params: descriptor.params || {},
                value: descriptor.value
            })
        }
    }
}

export class WebHandle {
    mainPath = ""
    init(mainPath: string, env?: (() => string) | string) {
        this.mainPath = mainPath.replace(/\\/g, "/")
        this.setEnv(env || "")

        // 合并一下啊各种模块
        this.routeMap.mergeModule(this.mainPath)
    }

    private globalMap = new HandleMap("global")
    private envMap = new HandleMap("env")
    private routeMap = new HandleMap("route")

    /**
    * 设置模块的归属
    */
    class(prePath?: string | NodeModule): ClassDecorator {
        return this.routeMap.class(prePath)
    }

    /**
     * 注册路由
     */
    route(Name?: string): MethodDecorator {
        return this.routeMap.route(Name);
    }

    /**
     * 注册参数检查
     */
    params(Name: string, type: SeParamConfigType, required: boolean, change: boolean): MethodDecorator {
        return this.routeMap.params(Name, type, required, change);
    }

    /**
     * 模块方法调用前的调用，主要是给数据处理提供前置准备
     */
    before(): MethodDecorator {
        return this.routeMap.before();
    }

    /**
     * 模块方法调用后调用，主要是给数据处理提供最后的操作
     */
    after(): MethodDecorator {
        return this.routeMap.after();
    }

    /**
     * 获取一个响应模块
     * @param prePath 可以设置相对路径字符串，或者模块对象
     */
    getModule(prePath: string | NodeModule) {
        if (typeof prePath != "string") {
            prePath = prePath.filename;
        }

        return this.routeMap.getModule(prePath)
    }

    getEnvModule() {
        return this.envMap.getModule(this.getEnv())
    }

    getGlobalModule() {
        return this.globalMap.getModule("")
    }

    // 当前的环境
    private _env: (() => string) | string = ""
    /**
     * 设置当前环境 （主要是提供给处理方法调用环境判断）
     * @param env 环境参数
     */
    setEnv(env: (() => string) | string) {
        this._env = env
    }

    /**
     * 获取当前环境
     */
    getEnv() {
        if (typeof this._env == "function") {
            return this._env()
        }
        else {
            return this._env;
        }
    }

    /**
     * 设置模块的归属
     */
    envClass(prePath?: string | NodeModule): ClassDecorator {
        return this.envMap.class(prePath)
    }

    /**
     * 模块方法调用前的调用，主要是给数据处理提供前置准备
     */
    envBefore(): MethodDecorator {
        return this.envMap.before();
    }

    /**
     * 模块方法调用后调用，主要是给数据处理提供最后的操作
     */
    envAfter(): MethodDecorator {
        return this.envMap.after();
    }

    /**
     * 全局模块
     */
    globalClass(): ClassDecorator {
        return this.globalMap.class("")
    }

    /**
     * 模块方法调用前的调用，主要是给数据处理提供前置准备
     */
    globalBefore(): MethodDecorator {
        return this.globalMap.before();
    }

    /**
     * 模块方法调用后调用，主要是给数据处理提供最后的操作
     */
    globalAfter(): MethodDecorator {
        return this.globalMap.after();
    }
}